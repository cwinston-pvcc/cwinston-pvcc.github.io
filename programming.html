<!DOCTYPE html>
<! -- NAME: Cary Winston
    PROGRAM PURPOSE: This program constructs a table of terms on programming algorithms and software testing
-->
<html>
<head>
<style>
table, th, td{
    border: 1px solid black;
            border-collapse: collapse;
}
</style>
</head>
<body>

<table style ="width:100%; color:tomato; background-color:#157f1f;">
    <tr style="height:50px; background-color:#4cb963; font-size:160%;"> 
        <th colspan="2">Programming Algorithms &  Software Testing Terminology Table</th>
    </tr>
    <tr>
        <th style="width:20%; text-align:left;">TERM</th> 
        <th style="text-align:left;">DEFINITION</th>
    </tr>
    <tr>
        <td>Phases of Computer Programming Development:</td>
    </tr>
        <tr>
            <ul>
                <td>
                <li>Phase 1: Understand the problem</li>
                </td>
                <td>In this phase the user must analyze the problem and what the solution must do</td>
            </ul>
        </tr>
        <tr>
            <ul>
                <td>
                <li>Phase 2: Design an algorithm to solve the problem</li>
                </td>
                <td>Develop a comprehensive, logical sequence of steps to solve the problem</td>
            </ul>
        </tr>
    <tr>
        <ul>
            <td>
            <li>Phase 3: Write the program code in appropriate language based on the algorithm</li>
            </td>
            <td>Translate algorithm into a program written in a programming language</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Phase 4: Enter the program code and save</li>
            </td>
            <td>To enter the program into a computer so you can translate and execute it</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Phase 5: Execute the program</li>
            </td>
            <td>To run the program on the computer</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Phase 6: Test the program, find errors and debug, then retest</li>
            </td>
            <td>Test the program for syntactical and logical errors. Fix the errors.</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Phase 7: Document and evaluate the program</li>
            </td>
            <td> To document is for programmers to describe their product and the process they used in creating it in formal writing. To evaluate is to determine how well it meets the needs of the user</td>
        </ul>
    </tr>
    <tr>
        <td>Programming structures:</td>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Sequential structure: Top-down execution</li>
            </td>
            <td>A type of flow where one instrucion is executed at a time in the order that the instructions appear in a program</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Decision structures: if/then/else</li>
            </td>
            <td>A type of structure that allows the computer program to make a decision and change its behavior based on that decision</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Iterative (Looping): <br>while loop: continue looping as long as something is true<br>repeat/until loop: continue looping until something is true<br>for loop: loop a given number of times</li>
            </td>
            <td>Iterative looping is a type of structure in which a sequence of instructions is repeated until a specific end result is achieved</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Recursive structures: <br>repeat a set of instructions as a subtask of itself<br>Repetition continues until:<br>degenerative case, which is a termination condition, is met<br>(degenerative case, is also called a "base case")</li>
            </td>
            <td>Recursion is a type of structure in which one task is consumed within the other. When we complete the inner task or tasks, we return to continue the outer task</td>
        </ul>
    </tr>
    
    <tr>
        <td>Two classic programming/database problems</td>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Sorting: Descending order/ Ascending order<br>Sorting numbers<br>Sorting strings(in accordance with ASCII values</li>
            </td>
            <td>Descending order means the largest or last in the order will appear at the top of the list. For numbers the sort is largest to smallest. For letters/words, the sort is alphabetical from Z to A. Ascending order means the smallest or first in the order will appear at the top of the list. For numbers, the sort is smallest to largest. For letters/words, the sort is alphabetical from A to Z </td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Searching: find specific data that meet a certain criteria<br>In database:<br>Filters: temporary search<br>Queries: search criteria are saved so they don't have to be recreated </li>
            </td>
            <td>To filter data in a database is to select only those records that match certain criteria. A query is a request for information from a database expressed in a formal manner</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Two popular search techniques:<br>Sequential search: search from top to bottom or bottom to top, one item at a time<br>Binary search:<br>only works if data is SORTED first<br>start in the middle, then go to half of that, etc.</li>
            </td>
            <td>A sequential search is a method for finding an element in a list that starts at one end and checks each element of the list until a match is found or the whole list has been searched. A binary search works by repeatedly dividing in half the portion of the list that could contain the item, until the possible locations have been narrowed down to just one</td>
        </ul>
    </tr>
    <tr>
        <td>Two classic programming goals:</td>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Efficiency: Program takes minimal time and/or resources</li>
            </td>
            <td>The efficiency of a computer program optimizes its speed and memory requirements</td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Correctness: Program runs in expected ways and works for all expected conditions</li>
            </td>
            <td>Correctness focuses on ensuring that the program does what it is supposed to do</td>
        </ul>
    </tr>
    <tr>
        <td>Software testing and verification</td>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Kinds of tests:</li>
                <ol>
                    <li>Acceptance testing:</li>
                    <li>Integration testing:</li>
                    <li>Unit testing:</li>
                    <li>Functional testing:</li>
                    <li>Performance testing:</li>
                    <li>Regression testing:</li>
                    <li>Stress testing:</li>
                    <li>Usability testing:</li>
                </ol>    
            </td>
            <td>
                <ol>
                    <li>Acceptance testing is verifying whether the whole system works as intended</li>
                    <li>Integration testing is ensuring that software components or functions operate together</li>
                    <li>Unit testing is validating that each software unit performs as expected. A unit is the smallest testable component of an application</li>
                    <li>Functional testing is checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions</li>
                    <li>Performance testing is testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions</li>
                    <li>Regression testing is checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.</li>
                    <li>Stress testing is testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.</li>
                    <li>Usability testing is validating how well a customer can use a system or web application to complete a task.</li>
                </ol>    
            </td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Software testing is done to detect:</li>
                <ol>
                    <li>Architectural flaws</li>
                    <li>Poor design decisions</li>
                    <li>Invalid or incorrect functionality</li>
                    <li>Security vulnerabilities</li>
                    <li>Scalability issues</li>
                    
                </ol>    
            </td>
            
            <td>
                <ol>
                    <li>Architectural flaws are vulnerabilities in a software system that weaken the overall security of the system</li>
                    <li>Two common poor design decisions are breaking of one functionality during development of another and code not supporting future enhancements</li>
                    <li>Software has a functionality error if something it is expected to do is hard, awkward, confusing, or impossible</li>
                    <li>Security vulnerabilities are weaknesses or errors that have the potential to be leveraged by a threat agent</li>
                    <li>Scalability refers to the ability of a software system to perform well under an increased or expanding workload</li>
                    
                </ol>    
            </td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>Testing best practices:</li>
                <ol>
                    <li>Continuous testing</li>
                    <li>Configuration management</li>
                    <li>Service virtualization</li>
                    <li>Defect or "bug tracking"</li>
                    <li>Metrics and reporting</li>
                    
                </ol>    
            </td>
            <td>
                <ol>
                    <li>Project teams test each build as it becomes available. This type of software testing relies on test automation that is integrated with the deployment process. It enables software to be validated in realistic test environments earlier in the process - improving design and reducing risks.</li>
                    <li>Organizations centrally maintain test assets and track what software builds to test. Teams gain access to assets such as code, requirements, design documents, models, test scripts, and test results. Good systems include user authentication and audit trails to help teams meet compliance requirements with minimal administrative effort.</li>
                    <li>Testing environments may not be available, especially early in code development. Service virtualization simulates the services and systems that are missing or not yet completed, enabling teams to reduce dependencies and test sooner. They can reuse, deploy and change a configuration to test different scenarios without having to modify the original environment </li>
                    <li>Monitoring defects is important to both testing and development teams for measuring and improving quality. Automated tools allow teams to track defects, measure their scope and impact, and uncover related issues.</li>
                    <li>Reporting and analytics enable team members to share status, goals and test results. Advanced tools integrate project metrics and present results in a dashboard. Teams quickly see the overall health of a project and can monitor relationships between test, development and other project elements.</li>
                    
                </ol>    
            </td>
        </ul>
    </tr>
    <tr>
        <ul>
            <td>
            <li>From: IBM What is software testing?</li>
            </td>
            <td><a href="https://www.ibm.com/topics/software-testing" target="_blank"style="color:tomato">IBM Software Testing</a></td> 
        </ul>
        </tr>  
                                                                                                                          
</table>
</body>
</html>